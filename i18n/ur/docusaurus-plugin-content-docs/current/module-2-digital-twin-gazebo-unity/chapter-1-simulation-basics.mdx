---
id: chapter-1-simulation-basics
title: "Chapter 1 - Simulation Basics"
sidebar_label: "Chapter 1: Simulation Basics"
---

import ChapterActionsBar from '@site/src/components/learning/ChapterActionsBar';

# باب 1: سمولیشن کی بنیادی باتیں

<ChapterActionsBar />

## ڈیجیٹل ٹوئن کیا ہے؟

**ڈیجیٹل ٹوئن** ایک طبیعی نظام کی مجازی نقل ہے جو حقیقی وقت یا سمولیشن کی صورتحال میں اس کے رویے کی عکاسی کرتی ہے۔ روبوٹکس میں، ڈیجیٹل ٹوئن آپ کو یہ مواقع فراہم کرتا ہے:

- **بنانے سے پہلے ٹیسٹ کریں**: مہنگے ہارڈویئر کے بغیر روبوٹ ڈیزائنز کی توثیق کریں
- **محفوظ طریقے سے تربیت دیں**: روبوٹوں کو خطرناک کاموں (جیسے آگ سنبھالنا) کی تعلیم سمولیشن میں دیں
- **ڈیٹا تیار کریں**: AI ماڈلز کے لیے لاکھوں تربیتی مثالیں بنائیں
- **تیزی سے ڈیبگ کریں**: حقیقی دنیا میں ناکام ہونے والے منظرناموں کو دوبارہ چلائیں اور سست کریں

اسے پائلٹوں کے لیے فلائٹ سمولیٹر کی طرح سمجھیں۔ حقیقی 747 اڑانے سے پہلے، پائلٹ سمولیٹرز میں ہزاروں گھنٹے تربیت حاصل کرتے ہیں۔ اسی طرح، روبوٹ طبیعی دنیا کو چھونے سے پہلے سمولیشن میں لاکھوں بار تربیت حاصل کر سکتے ہیں۔

### ڈیجیٹل ٹوئنز فزیکل AI کے لیے کیوں اہم ہیں

حقیقی دنیا میں روبوٹوں کی تربیت:

- **مہنگی ہے**: تربیت کے دوران $50,000 کے ہیومنائیڈ روبوٹ کو توڑنا مہنگا پڑتا ہے
- **سست ہے**: حقیقی دنیا کے ڈیٹا اکٹھا کرنے میں مہینے لگتے ہیں
- **خطرناک ہے**: سیڑھیوں یا ٹریفک کے قریب نیویگیشن کی جانچ نقصان کا خطرہ ہے
- **محدود ہے**: آپ لیبارٹری میں بارش، آگ، یا صفر کشش ثقل کی سمولیشن نہیں کر سکتے

**ڈیجیٹل ٹوئنز اس کا حل فراہم کرتے ہیں۔** آپ:

- 1 دن میں 10 سال کے تجربے کی سمولیشن کر سکتے ہیں
- ایسے ماحول میں ٹیسٹ کر سکتے ہیں جو آپ کے پاس طبیعی طور پر نہیں ہیں (مریخ، پانی کے اندر، وغیرہ)
- سینکڑوں مجازی روبوٹس پر تربیت کو متوازی بنا سکتے ہیں
- محفوظ طریقے سے ناکام ہو سکتے ہیں اور غلطیوں سے سیکھ سکتے ہیں

---

## تعیناتی سے پہلے سمولیشن کیوں کریں؟

تصور کریں کہ آپ گودام میں کام کرنے کے لیے ہیومنائیڈ روبوٹ بنا رہے ہیں۔ سمولیشن کے بغیر، آپ کو ضرورت ہوگی:

1. مکمل روبوٹ بنائیں (مہینے + $100k+)
2. ٹیسٹ گودام ترتیب دیں
3. ہر منظر نامے کو دستی طور پر ٹیسٹ کریں (چلنا، اٹھانا، رکاوٹوں سے بچنا)
4. ہارڈویئر میں ترمیم کر کے بگز ٹھیک کریں (مہنگا!)
5. دوہرائیں

**سمولیشن کے ساتھ:**

1. سافٹ ویئر میں روبوٹ کا ماڈل بنائیں (دن)
2. مجازی گودام کے ماحول بنائیں
3. رات بھر ہزاروں منظرناموں کی جانچ کریں
4. کوڈ میں بگز ٹھیک کریں (سستا!)
5. صرف اعتماد کے ساتھ ہارڈویئر پر تعینات کریں

**نتیجہ:** تیز ترقی، کم لاگت، محفوظ جانچ۔

### حقیقی دنیا کی مثال: Tesla Optimus

Tesla اپنے Optimus ہیومنائیڈ روبوٹ کو سمولیشن استعمال کر کے تربیت دیتا ہے:

- وہ مجازی گھر، فیکٹریاں، اور گودام بناتے ہیں
- روبوٹ کپڑے تہہ کرنے، پرزے اٹھانے، ناہموار زمین پر چلنے جیسے کاموں کی مشق کرتا ہے
- AI لاکھوں سمولیٹڈ کوششوں سے سیکھتا ہے
- صرف تصدیق شدہ طرز عمل طبیعی روبوٹوں پر تعینات کیے جاتے ہیں

یہ **سم-ٹو-ریئل ٹرانسفر** قابل توسیع روبوٹ لرننگ کی کلید ہے۔

---

## فزکس سمولیشن: روبوٹوں کو کشش ثقل کے بارے میں سکھانا

روبوٹ طبیعی دنیا میں کام کرتے ہیں، جس کا مطلب ہے کہ انہیں ان قوانین کی پابندی کرنی چاہیے:

- **کشش ثقل**: اشیاء 9.8 m/s² کی رفتار سے نیچے گرتی ہیں
- **تصادم**: دو اشیاء ایک ہی جگہ پر نہیں ہو سکتیں
- **رگڑ**: پہیے برف پر پھسلتے ہیں، اسفالٹ پر گرفت رکھتے ہیں
- **جمود**: بھاری اشیاء تیز رفتاری کی مزاحمت کرتی ہیں

ایک **فزکس انجن** ان قوانین کو ریاضیاتی طور پر سمولیٹ کرتا ہے تاکہ روبوٹ حقیقت پسندانہ رویہ سیکھیں۔

### اہم فزکس تصورات

#### 1. کشش ثقل

ہر شے نیچے کی طرف قوت محسوس کرتی ہے۔ سمولیشن میں، آپ سیٹ کرتے ہیں:

```python
gravity = [0, 0, -9.81]  # معیاری زمین کی کشش ثقل (Z-axis اوپر کی طرف اشارہ کرتا ہے)
```

کشش ثقل کے بغیر، اشیاء تیرتی ہیں۔ بہت زیادہ، اور آپ کا روبوٹ کھڑا نہیں ہو سکتا۔

#### 2. تصادم کا پتہ لگانا

سمولیٹر چیک کرتا ہے کہ آیا اشیاء اوورلیپ ہو رہی ہیں اور دخول کو روکتا ہے۔

**مثال:** اگر روبوٹ کا ہاتھ ڈبے کی طرف حرکت کرتا ہے، تصادم کا پتہ لگانا:
- رابطے کا پتہ لگاتا ہے
- ردعمل کی قوتیں لگاتا ہے (ہاتھ رکتا ہے، ڈبہ حرکت کر سکتا ہے)
- رگڑ کی بنیاد پر گرفت یا پھسلن کی سمولیشن کرتا ہے

#### 3. رگڑ

یہ طے کرتا ہے کہ اشیاء ایک دوسرے کے خلاف کیسے پھسلتی ہیں۔

**کم رگڑ** (برف): روبوٹ کے پہیے آگے بڑھے بغیر گھومتے ہیں
**زیادہ رگڑ** (کنکریٹ پر ربڑ): روبوٹ کو کرشن ملتی ہے

Gazebo میں، آپ ہر مواد کے لیے رگڑ کی تعریف کرتے ہیں:

```xml
<friction>
  <ode>
    <mu>0.8</mu>  <!-- رگڑ کا گتانک (0=برف، 1=ربڑ) -->
  </ode>
</friction>
```

#### 4. کمیت اور جمود

بھاری اشیاء کو حرکت دینا اور گھمانا مشکل ہوتا ہے۔

**مثال:** 5kg کا ڈبہ اٹھانے والے روبوٹ بازو کو خالی ہاتھ اٹھانے سے زیادہ ٹارک کی ضرورت ہوتی ہے۔

URDF میں، آپ بیان کرتے ہیں:

```xml
<inertial>
  <mass value="5.0"/>  <!-- kg -->
  <inertia ixx="0.1" ixy="0" ixz="0" iyy="0.1" iyz="0" izz="0.1"/>
</inertial>
```

درست فزکس کا مطلب ہے **سم-ٹو-ریئل ٹرانسفر کام کرتا ہے**—جو سمولیشن میں کامیاب ہوتا ہے وہ حقیقت میں کامیاب ہوتا ہے۔

---

## Gazebo: صنعتی معیار کا روبوٹ سمولیٹر

**Gazebo** ایک اوپن سورس 3D روبوٹ سمولیٹر ہے جو ROS 2 کے ساتھ مضبوطی سے مربوط ہے۔ یہ ان کے لیے ڈیفالٹ انتخاب ہے:

- تعلیمی تحقیق (ہزاروں مقالوں میں استعمال)
- روبوٹکس مقابلے (DARPA Robotics Challenge)
- صنعتی پروٹو ٹائپنگ

### Gazebo کیوں؟

- **مفت اور اوپن سورس**
- **مضبوط ROS 2 انٹیگریشن**: وہی ROS 2 کوڈ سم اور حقیقی ہارڈویئر دونوں میں چلتا ہے
- **حقیقت پسند فزکس**: ODE، Bullet، یا Simbody انجنوں پر بنایا گیا
- **سینسر سمولیشن**: LiDAR، کیمرے، IMUs، GPS
- **قابل توسیع**: C++/Python میں کسٹم پلگ انز لکھیں

### Gazebo کا فن تعمیر

Gazebo پر مشتمل ہے:

1. **Gazebo Server**: فزکس سمولیشن چلاتا ہے (ہیڈلیس، کلاؤڈ پر چل سکتا ہے)
2. **Gazebo Client (GUI)**: سمولیشن کو بصری بناتا ہے
3. **پلگ انز**: کسٹم طرز عمل (سینسرز، کنٹرولرز، وغیرہ)

```
┌─────────────────────┐
│   Gazebo Client     │ ← بصری بناتا ہے (اختیاری)
│       (GUI)         │
└──────────┬──────────┘
           │
┌──────────▼──────────┐
│  Gazebo Server      │ ← فزکس + سینسرز چلاتا ہے
│  (Physics Engine)   │
└──────────┬──────────┘
           │
┌──────────▼──────────┐
│   ROS 2 Bridge      │ ← سینسر ڈیٹا کو ROS 2 ٹاپکس میں شائع کرتا ہے
└─────────────────────┘
```

### Gazebo انسٹال کرنا (Ubuntu 22.04)

Gazebo متعدد ورژنز میں آتا ہے۔ ROS 2 Humble کے لیے، **Gazebo Fortress** یا **Gazebo Garden** استعمال کریں۔

```bash
# Gazebo Garden انسٹال کریں
sudo apt update
sudo apt install gz-garden

# انسٹالیشن کی تصدیق کریں
gz sim --version
```

ROS 2 انٹیگریشن کے لیے:

```bash
sudo apt install ros-humble-ros-gz
```

---

## آپ کی پہلی Gazebo سمولیشن

آئیے ایک سادہ دنیا لانچ کریں جس میں زمینی سطح اور کشش ثقل ہو۔

### مرحلہ 1: ورلڈ فائل بنائیں

`empty_world.sdf` بنائیں:

```xml
<?xml version="1.0"?>
<sdf version="1.9">
  <world name="empty_world">

    <!-- فزکس کی ترتیبات -->
    <physics name="1ms" type="ode">
      <max_step_size>0.001</max_step_size>  <!-- 1ms ٹائم سٹیپ -->
      <real_time_factor>1</real_time_factor>  <!-- 1x حقیقی وقت کی رفتار -->
    </physics>

    <!-- روشنی -->
    <light name="sun" type="directional">
      <pose>0 0 10 0 0 0</pose>
      <diffuse>1 1 1 1</diffuse>
    </light>

    <!-- زمینی سطح -->
    <model name="ground_plane">
      <static>true</static>  <!-- حرکت نہیں کرتا -->
      <link name="link">
        <collision name="collision">
          <geometry>
            <plane>
              <normal>0 0 1</normal>  <!-- اوپر کی طرف اشارہ کرتا ہے -->
            </plane>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
            </plane>
          </geometry>
          <material>
            <ambient>0.8 0.8 0.8 1</ambient>
          </material>
        </visual>
      </link>
    </model>

  </world>
</sdf>
```

### مرحلہ 2: Gazebo لانچ کریں

```bash
gz sim empty_world.sdf
```

آپ کو روشنی کے ساتھ ایک سرمئی زمینی سطح نظر آئے گی۔ یہ آپ کا خالی کینوس ہے!

### مرحلہ 3: ایک سادہ روبوٹ شامل کریں

آئیے ایک پہیوں والا روبوٹ شامل کریں۔ `simple_robot.sdf` بنائیں:

```xml
<?xml version="1.0"?>
<sdf version="1.9">
  <model name="simple_robot">
    <pose>0 0 0.1 0 0 0</pose>  <!-- پوزیشن: X Y Z Roll Pitch Yaw -->

    <!-- مرکزی جسم -->
    <link name="body">
      <inertial>
        <mass>10.0</mass>
        <inertia>
          <ixx>0.5</ixx>
          <iyy>0.5</iyy>
          <izz>0.5</izz>
        </inertia>
      </inertial>

      <collision name="body_collision">
        <geometry>
          <box>
            <size>0.5 0.3 0.2</size>  <!-- لمبائی چوڑائی اونچائی -->
          </box>
        </geometry>
      </collision>

      <visual name="body_visual">
        <geometry>
          <box>
            <size>0.5 0.3 0.2</size>
          </box>
        </geometry>
        <material>
          <ambient>0 0 1 1</ambient>  <!-- نیلا -->
        </material>
      </visual>
    </link>

    <!-- بائیں پہیہ -->
    <link name="left_wheel">
      <pose>0.15 0.2 0 -1.5707 0 0</pose>  <!-- 90° گھمایا گیا تاکہ رول ہو -->
      <inertial>
        <mass>1.0</mass>
        <inertia>
          <ixx>0.01</ixx>
          <iyy>0.01</iyy>
          <izz>0.01</izz>
        </inertia>
      </inertial>

      <collision name="collision">
        <geometry>
          <cylinder>
            <radius>0.1</radius>
            <length>0.05</length>
          </cylinder>
        </geometry>
      </collision>

      <visual name="visual">
        <geometry>
          <cylinder>
            <radius>0.1</radius>
            <length>0.05</length>
          </cylinder>
        </geometry>
        <material>
          <ambient>0 1 0 1</ambient>  <!-- سبز -->
        </material>
      </visual>
    </link>

    <!-- جسم کو بائیں پہیے سے جوڑنے والا جوائنٹ -->
    <joint name="left_wheel_joint" type="revolute">
      <parent>body</parent>
      <child>left_wheel</child>
      <axis>
        <xyz>0 1 0</xyz>  <!-- Y-axis کے گرد گھومتا ہے -->
        <limit>
          <lower>-1e16</lower>  <!-- لامحدود گردش -->
          <upper>1e16</upper>
        </limit>
      </axis>
    </joint>

    <!-- دایاں پہیہ (بائیں کی آئینہ) -->
    <link name="right_wheel">
      <pose>0.15 -0.2 0 -1.5707 0 0</pose>
      <!-- (بائیں پہیے جیسی ساخت) -->
    </link>

    <joint name="right_wheel_joint" type="revolute">
      <parent>body</parent>
      <child>right_wheel</child>
      <axis>
        <xyz>0 1 0</xyz>
      </axis>
    </joint>

  </model>
</sdf>
```

اس روبوٹ کو `empty_world.sdf` میں شامل کریں یہ شامل کر کے:

```xml
<include>
  <uri>model://simple_robot</uri>
</include>
```

اب جب آپ Gazebo لانچ کریں گے، تو آپ کو دو سبز پہیوں کے ساتھ ایک نیلا ڈبہ نظر آئے گا!

---

## سینسرز کی سمولیشن: LiDAR، کیمرے، اور IMUs

روبوٹ سینسرز کے ذریعے دنیا کو محسوس کرتے ہیں۔ Gazebo ان سینسرز کی سمولیشن کرتا ہے اور ROS 2 ٹاپکس میں ڈیٹا شائع کرتا ہے۔

### 1. LiDAR (لیزر سکینر)

**LiDAR** لیزر شعاعیں چلاتا ہے اور رکاوٹوں تک کی دوری ناپتا ہے۔ نیویگیشن کے لیے ضروری۔

اپنے روبوٹ کے URDF/SDF میں شامل کریں:

```xml
<sensor name="lidar" type="gpu_lidar">
  <pose>0.2 0 0.15 0 0 0</pose>  <!-- روبوٹ کے سامنے نصب -->
  <topic>/scan</topic>  <!-- اس ROS 2 ٹاپک میں شائع کرتا ہے -->

  <update_rate>10</update_rate>  <!-- 10Hz -->

  <lidar>
    <scan>
      <horizontal>
        <samples>360</samples>  <!-- 360° کوریج -->
        <resolution>1</resolution>
        <min_angle>-3.14159</min_angle>
        <max_angle>3.14159</max_angle>
      </horizontal>
    </scan>
    <range>
      <min>0.1</min>  <!-- کم سے کم پتہ لگانے کی دوری -->
      <max>10.0</max>  <!-- زیادہ سے زیادہ پتہ لگانے کی دوری -->
    </range>
  </lidar>
</sensor>
```

**ROS 2 میں**، فاصلے کی پیمائش حاصل کرنے کے لیے `/scan` کو سبسکرائب کریں:

```python
from sensor_msgs.msg import LaserScan

def lidar_callback(msg):
    print(f"Detected obstacle at {min(msg.ranges)} meters")
```

### 2. ڈیپتھ کیمرہ

**ڈیپتھ کیمرے** (جیسے Intel RealSense) RGB تصاویر + ڈیپتھ معلومات فراہم کرتے ہیں۔

```xml
<sensor name="depth_camera" type="depth_camera">
  <pose>0.2 0 0.2 0 0 0</pose>
  <topic>/camera/depth</topic>

  <update_rate>30</update_rate>  <!-- 30 FPS -->

  <camera>
    <horizontal_fov>1.5707</horizontal_fov>  <!-- 90° نظارے کا میدان -->
    <image>
      <width>640</width>
      <height>480</height>
    </image>
    <clip>
      <near>0.1</near>
      <far>10.0</far>
    </clip>
  </camera>
</sensor>
```

**استعمال کا معاملہ:** آبجیکٹ کا پتہ لگانا، رکاوٹوں سے بچنا، 3D نقشہ سازی۔

### 3. IMU (Inertial Measurement Unit)

**IMUs** تیز رفتاری اور گردش کی پیمائش کرتے ہیں۔ ہیومنائیڈز میں توازن کے لیے اہم۔

```xml
<sensor name="imu" type="imu">
  <pose>0 0 0.1 0 0 0</pose>
  <topic>/imu</topic>

  <update_rate>100</update_rate>  <!-- تیز توازن کنٹرول کے لیے 100Hz -->

  <imu>
    <angular_velocity>
      <x><noise type="gaussian"><stddev>0.01</stddev></noise></x>
      <y><noise type="gaussian"><stddev>0.01</stddev></noise></y>
      <z><noise type="gaussian"><stddev>0.01</stddev></noise></z>
    </angular_velocity>
    <linear_acceleration>
      <x><noise type="gaussian"><stddev>0.1</stddev></noise></x>
      <y><noise type="gaussian"><stddev>0.1</stddev></noise></y>
      <z><noise type="gaussian"><stddev>0.1</stddev></noise></z>
    </linear_acceleration>
  </imu>
</sensor>
```

**ROS 2 میں**:

```python
from sensor_msgs.msg import Imu

def imu_callback(msg):
    print(f"Acceleration: {msg.linear_acceleration}")
    print(f"Angular velocity: {msg.angular_velocity}")
```

---

## ہائی فیڈیلیٹی رینڈرنگ کے لیے Unity

جبکہ Gazebo فزکس میں بہترین ہے، **Unity** فراہم کرتا ہے:

- **فوٹو ریئلسٹک رینڈرنگ**: روشنی، سائے، عکاسیں
- **انسانی کردار کی اینیمیشن**: انسان-روبوٹ تعامل کے منظرناموں کے لیے
- **VR/AR انٹیگریشن**: روبوٹوں کو مخلوط حقیقت کے ماحول میں تربیت دیں

### Gazebo بمقابلہ Unity: ہر ایک کب استعمال کریں

| خصوصیت | Gazebo | Unity |
|---------|--------|-------|
| **فزکس کی درستگی** | بہترین | اچھی |
| **بصری معیار** | بنیادی | فوٹو ریئلسٹک |
| **ROS 2 انٹیگریشن** | مقامی | پل کی ضرورت ہے |
| **رفتار** | تیز (ہیڈلیس موڈ) | سست (رینڈرنگ اوورہیڈ) |
| **استعمال کا معاملہ** | نیویگیشن، SLAM، کنٹرول | کمپیوٹر ویژن، HRI |

**عام ورک فلو:**

1. **Gazebo** میں تیار کریں اور ٹیسٹ کریں (تیز تکرار)
2. **Unity** میں حتمی تربیت (ویژن ماڈلز کے لیے حقیقت پسند بصریات)
3. **حقیقی ہارڈویئر** پر تعینات کریں

### Unity-ROS 2 پل

Unity قدرتی طور پر ROS 2 نہیں بولتا۔ آپ کو پل کی ضرورت ہے:

```
Unity Simulator
      ↓
   TCP/IP
      ↓
ROS 2 Bridge Node
      ↓
ROS 2 Topics
```

**سیٹ اپ (آسان):**

1. Unity Robotics Hub انسٹال کریں: [https://github.com/Unity-Technologies/Unity-Robotics-Hub](https://github.com/Unity-Technologies/Unity-Robotics-Hub)
2. ROS 2 کنیکٹر انسٹال کریں
3. اینڈپوائنٹس کنفیگر کریں

**مثال:** Unity سے ROS 2 میں کیمرہ تصاویر شائع کرنا:

```csharp
// Unity C# script
using Unity.Robotics.ROSTCPConnector;

void Start() {
    ROSConnection.GetOrCreateInstance().Subscribe<ImageMsg>("/camera/image", ProcessImage);
}

void ProcessImage(ImageMsg msg) {
    // Unity میں تصویر دکھائیں
}
```

---

## سم-ٹو-ریئل ٹرانسفر: چیلنج

**سم-ٹو-ریئل ٹرانسفر** سمولیشن میں تربیت یافتہ روبوٹوں کو حقیقی دنیا میں کام کرنے کے قابل بنانا ہے۔

### حقیقت کا خلا

سمولیشنز سادہ ہیں:

- فزکس کامل نہیں ہے (رگڑ، تشکیل)
- سینسرز مثالی ہیں (لینس کی بگاڑ، شور نہیں)
- ماحول صاف ہیں (کوئی دھول، روشنی میں تبدیلی نہیں)

**نتیجہ:** ایک روبوٹ جو سمولیشن میں بالکل کام کرتا ہے حقیقت میں ناکام ہو سکتا ہے۔

### حل

#### 1. ڈومین رینڈمائزیشن

تربیت کے دوران سمولیشن پیرامیٹرز میں تبدیلی لائیں:

- روشنی، ساخت، شے کی پوزیشنز کو بے ترتیب کریں
- سینسر شور شامل کریں
- رگڑ، کمیت، اور کشش ثقل میں معمولی تبدیلی کریں

**فائدہ:** روبوٹ مضبوط پالیسیاں سیکھتا ہے جو غیر یقینی کو سنبھالتی ہیں۔

#### 2. درست کیلیبریشن

حقیقی روبوٹ کے پیرامیٹرز ناپیں:

- اصل لنک کی لمبائی (CAD ماڈل نہیں)
- حقیقی موٹر ٹارک کے منحنی خطوط
- سینسر کیلیبریشن ڈیٹا

**فائدہ:** سمولیشن حقیقت سے زیادہ قریب سے میل کھاتی ہے۔

#### 3. بتدریج منتقلی

1. بنیادی مہارتیں سم میں سکھائیں (مثلاً، کھڑا ہونا)
2. حقیقی ہارڈویئر پر باریک کریں (مثلاً، ناہموار زمین پر توازن)

**فائدہ:** سم کی رفتار + حقیقی دنیا کی درستگی سے فائدہ اٹھائیں۔

---

## حقیقی دنیا کی تشبیہ: گاڑی چلانا سیکھنا

روبوٹ لرننگ کو گاڑی چلانا سیکھنے کی طرح سمجھیں:

- **سمولیشن**: ڈرائیونگ سمولیٹر میں مشق کریں (محفوظ، سستا، دہرایا جا سکتا ہے)
- **حقیقت کا خلا**: سمولیٹر پیڈل حقیقی کار سے مختلف محسوس ہوتے ہیں
- **سم-ٹو-ریئل ٹرانسفر**: پہلے خالی پارکنگ میں، پھر شہر کی سڑکوں پر چلائیں

**مجموعہ** سمولیشن + حقیقی مشق مہارت کا تیز ترین راستہ ہے۔

---

## اہم نکات

1. **ڈیجیٹل ٹوئنز** روبوٹوں کو مجازی دنیاؤں میں محفوظ اور تیزی سے تربیت دینے دیتے ہیں
2. **فزکس سمولیشن** (کشش ثقل، تصادم، رگڑ) روبوٹوں کو حقیقت پسندانہ رویہ سکھاتی ہے
3. **Gazebo** ROS 2 روبوٹ سمولیشن کا صنعتی معیار ہے
4. **سینسرز** (LiDAR، ڈیپتھ کیمرے، IMUs) کی سمولیشن حقیقت پسند ڈیٹا فراہم کرنے کے لیے کی جاتی ہے
5. **Unity** ویژن کاموں کے لیے فوٹو ریئلسٹک رینڈرنگ کے ساتھ Gazebo کی تکمیل کرتا ہے
6. **سم-ٹو-ریئل ٹرانسفر** حقیقت کے خلا کو پاٹنے کے لیے ڈومین رینڈمائزیشن اور کیلیبریشن کی ضرورت ہے

---

## ہاتھ سے عملی مشق

### ورزش 1: ڈراپ ٹیسٹ

Gazebo میں، زمین سے 1 میٹر اوپر معلق ایک کیوب بنائیں۔ اسے گرنے کی سمولیشن کریں۔

**سوالات:**
- زمین سے ٹکرانے میں کتنا وقت لگتا ہے؟ (فزکس استعمال کریں: distance = 0.5 × gravity × time²)
- اگر آپ کشش ثقل کو -20 m/s² پر سیٹ کرتے ہیں تو کیا ہوتا ہے؟ (دوگنی کشش ثقل)

### ورزش 2: سینسر کی بصری کاری

Gazebo میں اپنے روبوٹ میں LiDAR سینسر شامل کریں۔ اس کے ارد گرد رکاوٹیں رکھیں۔

**کام:** فاصلے کی ریڈنگ دیکھنے کے لیے `ros2 topic echo /scan` استعمال کریں۔ رکاوٹوں کو منتقل کریں اور دیکھیں کہ ریڈنگ کیسے بدلتی ہیں۔

### ورزش 3: رگڑ کا تجربہ

دو ریمپ بنائیں: ایک رگڑ 0.1 (برف) کے ساتھ، ایک رگڑ 0.9 (ربڑ) کے ساتھ۔ چوٹی پر ایک جیسے کیوب رکھیں۔

**سوال:** کون سا کیوب نیچے پھسلتا ہے؟ یہ روبوٹ کے پہیوں کی کرشن کو کیسے متاثر کرتا ہے؟

### ورزش 4: سم-ٹو-ریئل سوچ

آپ ایک روبوٹ کو سمولیشن میں بلاکس اسٹیک کرنے کی تربیت دیتے ہیں۔ جب حقیقی ہارڈویئر پر تعینات کیا جاتا ہے، تو بلاکس اکثر گرتے ہیں۔

**سوال:** کون سے سم-ٹو-ریئل عوامل اس کا سبب بن سکتے ہیں؟ کم از کم 3 کی فہرست بنائیں۔

**اشارہ:** سینسرز، فزکس، اور ماحولیاتی فرق پر غور کریں۔

---

## عام غلطیاں جو ابتدائی کرتے ہیں

1. **کمیت/جمود کو نظر انداز کرنا**: تمام لنکس کو 1kg پر سیٹ کرنا غیر حقیقت پسندانہ رویہ پیدا کرتا ہے
2. **تصادم جیومیٹری چھوڑنا**: روبوٹ دیواروں کے ذریعے "بھوت" بنتا ہے
3. **بہت تیز فزکس ٹائم سٹیپس**: سمولیشن پھٹتی ہے یا غیر مستحکم ہو جاتی ہے
4. **سینسر شور شامل نہیں کرنا**: کامل سمولیٹڈ ڈیٹا پر زیادہ فٹ ہونا
5. **صرف سم میں ٹیسٹنگ**: بالآخر حقیقی ہارڈویئر پر تصدیق کریں

---

## آگے کیا ہے؟

اگلے ابواب میں، ہم:

- ہیومنائیڈ روبوٹ کے لیے مکمل URDF ماڈل بنائیں گے
- Gazebo میں سمولیٹڈ LiDAR استعمال کر کے نیویگیشن نافذ کریں گے
- ویژن پر مبنی ہیرا پھیری کی تربیت کے لیے Unity کو مربوط کریں گے
- حقیقی روبوٹ (Jetson Orin) پر سم سے تربیت یافتہ ماڈل تعینات کریں گے

اب آپ سمجھ گئے ہیں کہ سمولیشن *کیوں* اور *کیسے* کام کرتی ہے۔ اگلا، ہم اسے ہیومنائیڈ روبوٹکس پر لاگو کریں گے!

---

**گہری سیکھنے کے لیے وسائل:**

- [Gazebo Documentation](https://gazebosim.org/docs)
- [SDF Format Specification](http://sdformat.org/)
- [Unity Robotics Hub](https://github.com/Unity-Technologies/Unity-Robotics-Hub)
- [Sim-to-Real Transfer (Research Paper)](https://arxiv.org/abs/1703.06907)
